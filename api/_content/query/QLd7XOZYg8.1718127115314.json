{"_path":"/architecture","_dir":"","_draft":false,"_partial":false,"_locale":"","title":"Architecture","description":"Baked has an architectural core that is designed to allow us to build software\nwith any architectural style. Core idea is to enable a good separation of\nconcerns without causing any repetitive work. To achieve this Baked breaks down\nan application into following components: domain objects, layers and features.","pages":["application","layer","feature"],"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"architecture"},"children":[{"type":"text","value":"Architecture"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Baked has an architectural core that is designed to allow us to build software\nwith any architectural style. Core idea is to enable a good separation of\nconcerns without causing any repetitive work. To achieve this Baked breaks down\nan application into following components: domain objects, layers and features."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Let's dive into each type of software component to have a better understanding\nof how Baked is structured."}]},{"type":"element","tag":"h2","props":{"id":"domain-objects"},"children":[{"type":"text","value":"Domain Objects"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"At the core of an application lies its domain logic. By this we understand the\nvery reason for an application to exist. Everything else exists only to expose\nthis domain to outside world. So first component is domain objects;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"diagram","src":"./README-1.svg"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"layers"},"children":[{"type":"text","value":"Layers"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Second component is layers. Every layer introduces a new technology, such as a\ndatabase server, message queue server or a framework, into your application\narchitecture."}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"!TIP"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Layers are named after the concept of their technology."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"diagram","src":"./README-2.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In this example, "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"HttpServer"}]},{"type":"text","value":" introduces the concept of web as a layer through\nthe "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ASP.NET Core"}]},{"type":"text","value":" technology. Also, "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"DataAccess"}]},{"type":"text","value":" introduces the concept of\nrelational databases as a layer through the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"NHibernate"}]},{"type":"text","value":" framework."}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"!NOTE"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Domain"}]},{"type":"text","value":" is a unique layer that introduces the business logic of an\napplication by encapsulating its domain objects. It processes the assemblies\nto create an application schema, so that it can be used in creating\nconfiguration, conventions and/or generating source code."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For domain objects to be exposed as API endpoints or mapped onto a relational\ndatabase, layers require an insight about how to interpret domain objects."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This is why every layer comes with its own configuration that is specific to\nthe technology it uses. Configurations may contain a set of helper classes\nand/or facade methods that makes it easy to build a certain type of\nconfiguration, but they do "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"not"}]},{"type":"text","value":" have opinions upfront."}]},{"type":"element","tag":"h2","props":{"id":"features"},"children":[{"type":"text","value":"Features"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Finally, features connect layers in an opinionated way to introduce new\nbehaviours to the application. Features consist of two parts; an optional\nabstraction (port) and a required implementation (adapter)."}]},{"type":"element","tag":"h3","props":{"id":"abstraction"},"children":[{"type":"text","value":"Abstraction"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"An abstraction is the library that contains all common classes, interfaces,\nattributes, if any, for a feature. It is the only accessible part of a feature\nfrom domain objects or from other feature implementations."}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"!NOTE"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Each feature has only one abstraction, named after the ability it provides,\ne.g. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Authentication"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Lifetime"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Logging"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Orm"}]},{"type":"text","value":" etc."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"diagram","src":"./README-3.svg"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"implementation"},"children":[{"type":"text","value":"Implementation"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This is the implementation part of a feature that provides concrete\nimplementations for the interfaces defined in the abstraction, along with\nopinionated configurations using the configuration API of the corresponding\nlayer(s)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Features may have multiple implementations, each named after its corresponding\ndesign or technology, e.g. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Authentication.FixedBearerToken"}]},{"type":"text","value":" and\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Database.MySql"}]},{"type":"text","value":"."}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"!TIP"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Lifetime"}]},{"type":"text","value":" represents lifetime feature that provides an API to your domain to\nregister services in different lifetimes. "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Lifetime.Singleton"}]},{"type":"text","value":" and\n"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Lifetime.Transient"}]},{"type":"text","value":" are two different implementations of how you register and\nretrieve your domain objects from dependency injection."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In conclusion, feature implementations serve as bridges, connecting layers to\neach other through their opinionated configurations. Below is a complete sample\narchitecture, showcasing the integration of domain logic, layers and features;"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"diagram","src":"./README-4.svg"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"domain-objects","depth":2,"text":"Domain Objects"},{"id":"layers","depth":2,"text":"Layers"},{"id":"features","depth":2,"text":"Features","children":[{"id":"abstraction","depth":3,"text":"Abstraction"},{"id":"implementation","depth":3,"text":"Implementation"}]}]}},"_type":"markdown","_id":"content:architecture:index.md","_source":"content","_file":"architecture/index.md","_extension":"md"}