using Baked.Architecture;
using Baked.Business;
using Baked.Orm;
using FluentNHibernate.Conventions.Helpers;
using Humanizer;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.OpenApi.Models;

namespace Baked.IdCodingStyle.AutoGenerated;

public class AutoGeneratedIdCodingStyeFeature : IFeature<IdCodingStyleConfigurator>
{
    public void Configure(LayerConfigurator configurator)
    {
        configurator.ConfigureDomainModelBuilder(builder =>
        {
            builder.Conventions.SetPropertyAttribute(
                when: c => c.Type.Has<EntityAttribute>() && c.Property.Name == "Id" && c.Property.PropertyType.Is<Id>(),
                attribute: c => new IdAttribute(typeof(AutoGeneratedIdUserType), c.Property.Name, c.Property.Name.Kebaberize())
            );
        });

        configurator.ConfigureGeneratedAssemblyCollection(generatedAssemblies =>
        {
            configurator.UsingDomainModel(domain =>
            {
                generatedAssemblies.Add(nameof(AutoGeneratedIdCodingStyeFeature),
                    assembly =>
                    {
                        assembly.AddReferenceFrom<AutoGeneratedIdCodingStyeFeature>();

                        foreach (var entity in domain.Types.Having<EntityAttribute>())
                        {
                            var idProperty = entity.GetMembers().Properties.First(p => p.CustomAttributes.Contains<IdAttribute>());
                            if (idProperty.Name != "Id") { continue; }
                            if (!idProperty.PropertyType.Is<Id>()) { continue; }

                            var idAttribute = idProperty.Get<IdAttribute>();
                            if (idAttribute.Type != typeof(AutoGeneratedIdUserType)) { continue; }

                            assembly.AddCodes(new AutoGeneratedIdMapperTemplate(entity));

                            entity.Apply(t => assembly.AddReferenceFrom(t));
                        }
                    },
                    usings:
                    [
                        "Baked.IdCodingStyle",
                        "Baked.IdCodingStyle.AutoGenerated",
                        "Baked.Orm",
                        "FluentNHibernate",
                        "FluentNHibernate.Automapping",
                        "FluentNHibernate.Diagnostics",
                        "FluentNHibernate.Conventions.Helpers",
                        "FluentNHibernate.Mapping",
                        "NHibernate.Linq",
                    ]
                );
            });
        });

        configurator.ConfigureAutoPersistenceModel(model =>
        {
            model.Conventions.Add(ForeignKey.EndsWith("Id"));

            configurator.UsingGeneratedContext(context =>
            {
                var idMapperTypes = context.Assemblies[nameof(AutoGeneratedIdCodingStyeFeature)].GetExportedTypes().Where(t => t.IsAssignableTo(typeof(IIdMapper)));
                foreach (var idMapperType in idMapperTypes)
                {
                    var idMapper = (IIdMapper?)Activator.CreateInstance(idMapperType) ?? throw new($"Cannot create instance of {idMapperType}");

                    idMapper.Configure(model);
                }
            });
        });

        configurator.ConfigureAutomapping(automapping =>
        {
            automapping.MemberIsId.Add(m => m.PropertyType == typeof(Id) && m.Name == "Id");
        });

        configurator.ConfigureMvcNewtonsoftJsonOptions(options =>
        {
            options.SerializerSettings.Converters.Add(new IdJsonConverter());
        });

        configurator.ConfigureSwaggerGenOptions(swaggerGenOptions =>
        {
            // Use 'MapType' instead of 'ISchemaFilter' for 
            // not render 'Id' as a reference and display properties
            // instead of only '$ref' in schemas
            swaggerGenOptions.MapType<Id>(() => new OpenApiSchema { Type = "string" });
        });
    }
}